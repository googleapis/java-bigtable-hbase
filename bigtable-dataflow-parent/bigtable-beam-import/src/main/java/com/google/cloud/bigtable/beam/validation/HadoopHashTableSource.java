/*
 * Copyright 2020 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.bigtable.beam.validation;

import static com.google.cloud.bigtable.beam.validation.SyncTableUtils.createConfiguration;
import static com.google.cloud.bigtable.beam.validation.SyncTableUtils.immutableBytesToString;

import com.google.bigtable.repackaged.com.google.common.annotations.VisibleForTesting;
import com.google.cloud.bigtable.beam.validation.HadoopHashTableSource.RangeHash;
import com.google.cloud.bigtable.beam.validation.TableHashWrapper.TableHashReader;
import com.google.common.base.Objects;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import javax.annotation.Nullable;
import org.apache.beam.sdk.coders.Coder;
import org.apache.beam.sdk.coders.DefaultCoder;
import org.apache.beam.sdk.io.BoundedSource;
import org.apache.beam.sdk.options.PipelineOptions;
import org.apache.beam.sdk.options.ValueProvider;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.hadoop.hbase.HConstants;
import org.apache.hadoop.hbase.io.ImmutableBytesWritable;

/**
 * A beam source to read output of Hadoop HashTable job. The source creates 1 workitem per HashTable
 * data file and emits a row-range/hash pair.
 */
class HadoopHashTableSource extends BoundedSource<RangeHash> implements Serializable {

  private static final long serialVersionUID = 2383724L;

  /**
   * A simple POJO encapsulating a row range and the corresponding hash generated by HashTable job.
   */
  @DefaultCoder(RangeHashCoder.class)
  public static class RangeHash {

    public final ImmutableBytesWritable startInclusive;
    public final ImmutableBytesWritable stopExclusive;
    public final ImmutableBytesWritable hash;

    private RangeHash(
        ImmutableBytesWritable startInclusive,
        ImmutableBytesWritable stopExclusive,
        ImmutableBytesWritable hash) {
      this.startInclusive = startInclusive;
      this.stopExclusive = stopExclusive;
      this.hash = hash;
    }

    static RangeHash of(
        ImmutableBytesWritable startInclusive,
        ImmutableBytesWritable stopExclusive,
        ImmutableBytesWritable hash) {
      Preconditions.checkNotNull(startInclusive);
      Preconditions.checkNotNull(stopExclusive);
      Preconditions.checkNotNull(hash);
      return new RangeHash(startInclusive, stopExclusive, hash);
    }

    @Override
    public String toString() {
      return String.format(
          "RangeHash{ range = [ %s, %s), hash: %s }",
          immutableBytesToString(startInclusive),
          immutableBytesToString(stopExclusive),
          immutableBytesToString(hash));
    }

    @Override
    public boolean equals(Object o) {
      if (this == o) {
        return true;
      }
      if (!(o instanceof RangeHash)) {
        return false;
      }
      RangeHash rangeHash = (RangeHash) o;
      return Objects.equal(startInclusive, rangeHash.startInclusive)
          && Objects.equal(stopExclusive, rangeHash.stopExclusive)
          && Objects.equal(hash, rangeHash.hash);
    }

    @Override
    public int hashCode() {
      return Objects.hashCode(startInclusive, stopExclusive, hash);
    }
  }

  public static final Log LOG = LogFactory.getLog(HadoopHashTableSource.class);

  private ValueProvider<String> projectId;

  // Path to the output of HashTable job. Usually in GCS.
  private ValueProvider<String> sourceHashDir;

  // Coder to encode/decode the RangeHash
  private RangeHashCoder coder;

  // Row range owned by this source.
  @VisibleForTesting @Nullable ImmutableBytesWritable startRowInclusive;

  @VisibleForTesting @Nullable ImmutableBytesWritable stopRowExclusive;

  private TableHashWrapperFactory tableHashWrapperFactory;

  public HadoopHashTableSource() {
    this.coder = new RangeHashCoder();
  }

  /**
   * Creates a HadoopHashTableSource that reads HashTable data from hashTableOutputDir in GCS bucket
   * in project $(projectId).
   */
  public HadoopHashTableSource(
      ValueProvider<String> projectId, ValueProvider<String> sourceHashDir) {
    this(projectId, sourceHashDir, /*startRowInclusive*/ null, /*stopRowExclusive*/ null);
  }

  /**
   * Constructor to initialize a HadoopHashTableSource for a given row-range. Used for creating
   * split sources.
   */
  @VisibleForTesting
  HadoopHashTableSource(
      ValueProvider<String> projectId,
      ValueProvider<String> sourceHashDir,
      @Nullable ImmutableBytesWritable startRowInclusive,
      @Nullable ImmutableBytesWritable stopRowExclusive) {
    this(
        projectId,
        sourceHashDir,
        startRowInclusive,
        stopRowExclusive,
        new TableHashWrapperFactory());
  }

  @VisibleForTesting
  HadoopHashTableSource(
      ValueProvider<String> projectId,
      ValueProvider<String> hadoopHashTableOutputDir,
      @Nullable ImmutableBytesWritable startRowInclusive,
      @Nullable ImmutableBytesWritable stopRowExclusive,
      TableHashWrapperFactory tableHashWrapperFactory) {
    this.coder = new RangeHashCoder();
    this.projectId = projectId;
    this.sourceHashDir = hadoopHashTableOutputDir;
    // startRow and stopRow will be null when the template is initialized. startRow and stopRow are
    // read from the hashTableOutputDir, which is only available at pipeline runtime.
    this.startRowInclusive = startRowInclusive;
    this.stopRowExclusive = stopRowExclusive;
    this.tableHashWrapperFactory = tableHashWrapperFactory;
  }

  @Override
  public List<? extends BoundedSource<RangeHash>> split(
      long desiredBundleSizeBytes, PipelineOptions options) throws IOException {
    // This method relies on the partitioning done by HBase-HashTable job. There is a possibility
    // of stragglers. SyncTable handles it by using a group by and further splitting workitems.
    TableHashWrapper hash =
        tableHashWrapperFactory.getTableHash(projectId.get(), sourceHashDir.get());

    ImmutableList<ImmutableBytesWritable> partitions = hash.getPartitions();
    int numPartitions = partitions.size();

    List<HadoopHashTableSource> splitSources = new ArrayList<>(numPartitions + 1);
    if (numPartitions == 0) {
      // There are 0 partitions and 1 hashfile, return single source with full key range.
      splitSources.add(
          new HadoopHashTableSource(
              projectId,
              sourceHashDir,
              hash.getStartRow(),
              hash.getStopRow(),
              tableHashWrapperFactory));
      return splitSources;
    }

    // Use the HashTable start key. The value is HConstants.EMPTY_START_ROW for full table scan.
    ImmutableBytesWritable startRow = hash.getStartRow();
    ImmutableBytesWritable stopRow = hash.getStopRow();

    // The output of HashTable is organized as partition file and a set of datafiles.
    // Partition file contains a list of partitions, these partitions split the key-range of a table
    // into roughly equal row-ranges and hashes for these row-ranges are stored in a single
    // datafile.
    //
    // There are always numPartitions +1 data files. Datafile(i) covers hashes for [partition{i-1},
    // partition{i}).
    // So a partition file containing entries [b,f] for a table with row range [a,z] will have 3
    // data files containing hashes.
    // file0 will contain [a(startRow), b), file1 will contain [b,f), and file3 will contain
    // [f,z(stopRow))
    for (int i = 0; i < numPartitions; i++) {
      LOG.debug(
          "Adding: ["
              + immutableBytesToString(startRow.get())
              + ", "
              + immutableBytesToString(partitions.get(i).get())
              + "]");
      splitSources.add(
          new HadoopHashTableSource(
              projectId, sourceHashDir, startRow, partitions.get(i), tableHashWrapperFactory));
      startRow = partitions.get(i);
    }
    // Add the last range for [lastPartition, stopRow).
    LOG.debug(
        "Adding: ["
            + immutableBytesToString(startRow.get())
            + ", "
            + immutableBytesToString(stopRow.get())
            + "]");
    // Add the last range for [lastPartition, stopRow).
    splitSources.add(
        new HadoopHashTableSource(
            projectId,
            sourceHashDir,
            partitions.get(numPartitions - 1),
            stopRow,
            tableHashWrapperFactory));
    LOG.info("Returning " + splitSources.size() + " sources from " + numPartitions + " partitions");
    return splitSources;
  }

  @Override
  public Coder<RangeHash> getOutputCoder() {
    return coder;
  }

  @Override
  public long getEstimatedSizeBytes(PipelineOptions options) throws Exception {
    // HashTable data files don't expose a method to estimate size or lineCount.
    return 0;
  }

  @Override
  public BoundedReader createReader(PipelineOptions options) throws IOException {
    TableHashWrapper hash =
        tableHashWrapperFactory.getTableHash(projectId.get(), sourceHashDir.get());

    // The row range for an un-split source is determined from the output of HashTable job.
    // HashTableOutputDir is a runtime parameter and hence not available at construction time, so
    // populate the start and stop here.
    if (startRowInclusive == null || stopRowExclusive == null) {
      startRowInclusive = hash.getStartRow();
      stopRowExclusive = hash.getStopRow();
    }

    return new HashBasedReader(
        this,
        startRowInclusive,
        stopRowExclusive,
        hash.newReader(
            createConfiguration(this.projectId.get(), this.sourceHashDir.get()),
            startRowInclusive));
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (!(o instanceof HadoopHashTableSource)) {
      return false;
    }
    HadoopHashTableSource that = (HadoopHashTableSource) o;
    return Objects.equal(projectId, that.projectId)
        && Objects.equal(sourceHashDir, that.sourceHashDir)
        && Objects.equal(startRowInclusive, that.startRowInclusive)
        && Objects.equal(stopRowExclusive, that.stopRowExclusive);
  }

  @Override
  public int hashCode() {
    return Objects.hashCode(projectId, sourceHashDir, coder, startRowInclusive, stopRowExclusive);
  }

  @Override
  public String toString() {
    return "HadoopHashTableSource ["
        + immutableBytesToString(startRowInclusive)
        + ", "
        + immutableBytesToString(stopRowExclusive)
        + ')';
  }

  private void writeObject(ObjectOutputStream s) throws IOException {
    s.writeObject(projectId);
    s.writeObject(sourceHashDir);
    s.writeObject(tableHashWrapperFactory);
    // Start and Stop can be null, write a boolean to indicate if start/stop is expected.
    if (startRowInclusive == null) {
      s.writeBoolean(false);
    } else {
      s.writeBoolean(true);
      s.writeObject(startRowInclusive.copyBytes());
    }

    if (stopRowExclusive == null) {
      s.writeBoolean(false);
    } else {
      s.writeBoolean(true);
      s.writeObject(stopRowExclusive.copyBytes());
    }
  }

  private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {
    projectId = (ValueProvider<String>) s.readObject();
    sourceHashDir = (ValueProvider<String>) s.readObject();
    tableHashWrapperFactory = (TableHashWrapperFactory) s.readObject();
    // start/stop can be null, they are preceded by a boolean indicating their presence.
    if (s.readBoolean() == true) {
      startRowInclusive = new ImmutableBytesWritable((byte[]) s.readObject());
    }
    if (s.readBoolean() == true) {
      stopRowExclusive = new ImmutableBytesWritable((byte[]) s.readObject());
    }
  }

  @VisibleForTesting
  static class HashBasedReader extends BoundedReader<RangeHash> {

    private final HadoopHashTableSource source;
    private final TableHashReader reader;

    @VisibleForTesting final ImmutableBytesWritable startRowInclusive;
    @VisibleForTesting final ImmutableBytesWritable stopRowExclusive;

    private long numKeys = 0;
    // Flag indicating that this workitem is finished.
    private boolean isDone = false;
    private ImmutableBytesWritable currentRangeStartKey;
    // Hash for the current range.
    private ImmutableBytesWritable currentHash;
    private RangeHash currentRangeHash;

    public HashBasedReader(
        HadoopHashTableSource source,
        ImmutableBytesWritable startRowInclusive,
        ImmutableBytesWritable stopRowExclusive,
        TableHashReader reader) {
      this.source = source;
      this.startRowInclusive = startRowInclusive;
      this.stopRowExclusive = stopRowExclusive;
      this.reader = reader;
    }

    @Override
    public boolean start() throws IOException {
      LOG.debug(
          "Starting a new reader at key range ["
              + immutableBytesToString(startRowInclusive)
              + " ,"
              + immutableBytesToString(stopRowExclusive)
              + ").");
      numKeys = 0;

      if (readNextKey()) {
        // Dataflow calls start, followed by getCurrent. HashBased reader needs to read on TableHash
        // twice to return a RangeHash since it specifies both range-start and range-end.
        advance();
        return true;
      }

      isDone = true;
      return false;
    }

    @Override
    public boolean advance() throws IOException {
      if (isDone) {
        LOG.debug("Ending workitem at key " + immutableBytesToString(currentRangeStartKey) + " .");
        return false;
      }

      ImmutableBytesWritable startKey = this.currentRangeStartKey;
      ImmutableBytesWritable hash = this.currentHash;

      // if there is nothing to read, we are done. readNextKey advances the currentRangeStartKey.
      isDone = !readNextKey();
      currentRangeHash = RangeHash.of(startKey, currentRangeStartKey, hash);

      return true;
    }

    // Returns true if a key can be read for this workitem.
    private boolean readNextKey() throws IOException {
      if (reader.next()) {
        numKeys++;
        currentRangeStartKey = reader.getCurrentKey();
        if ( // StopRow is not set, everything is in bounds.
        (stopRowExclusive.equals(HConstants.EMPTY_END_ROW)
            || currentRangeStartKey.compareTo(stopRowExclusive) < 0)) { // currentKey < stopKey
          // There is a key to read and the key is within the bounds of this workitem. Return true.
          currentHash = reader.getCurrentHash();
          return true;
        } else {
          // There is a key to read but its outside of the bounds of this workitem.
          currentHash = null;
          return false;
        }
      }

      // Nothing left to read for this workitem. Next range would have started from
      // stopRowExclusive.
      currentRangeStartKey = stopRowExclusive;
      currentHash = null;
      return false;
    }

    @Override
    public RangeHash getCurrent() {
      return currentRangeHash;
    }

    @Override
    public void close() throws IOException {
      LOG.info(
          "Finishing a reader for key range ["
              + immutableBytesToString(startRowInclusive)
              + " ,"
              + immutableBytesToString(stopRowExclusive)
              + ") after reading "
              + numKeys
              + " keys. Ending at "
              + immutableBytesToString(currentRangeStartKey));
      reader.close();
    }

    @Override
    public BoundedSource<RangeHash> getCurrentSource() {
      return source;
    }
  }
}
